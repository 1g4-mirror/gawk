#!/bin/sh

# Use this for debugging the test cases.
# The resulting textual output will not destroy the test cases.
set -x
# After test case execution, the output can be found in
# build/Testing/Temporary/LastTest.log

export PATH=$PATH:/c/MinGW/msys/1.0/bin
export GAWKEXE=$1
export TESTCASE=$2
export OPTION=$3
TESTHOME=$(dirname ${0})/../test
export AWKPATH=${TESTHOME}
export AWKLIBPATH=$(dirname ${GAWKEXE})/extension/
export LANG=C
# Is this shell running in a native MinGW shell (MSYS) ?
if test -n "$COMSPEC"; then
  # Ignore all differences in white space.
  COMPARE="diff -w"
else
  # This is a shell running in Unix environment.
  COMPARE="cmp"
fi

# Each test case that cannot be handle in the "standard way" shall
# be implemented as a function here.
function testext() {
  $GAWKEXE '/^(@load|BEGIN)/,/^}/' ${TESTHOME}/../extension/testext.c > testext.awk
  $GAWKEXE -f ${TESTCASE}.awk  > ${TESTHOME}/_${TESTCASE} 2>&1 || echo EXIT CODE: $? >> ${TESTHOME}/_${TESTCASE}
  rm -f testext.awk
}

# Is this test case implemented as a function ?
if [ "$( type -t $TESTCASE )" = "function" ]
then
  $TESTCASE
# If no function exists, then treat the test case in standard way.
elif test -r ${TESTHOME}/${TESTCASE}.in
# Any existing .in file will be redirected to standard input.
then
  $GAWKEXE ${OPTION} -f ${TESTCASE}.awk  < ${TESTHOME}/${TESTCASE}.in > ${TESTHOME}/_${TESTCASE} 2>&1 || echo EXIT CODE: $? >> ${TESTHOME}/_${TESTCASE}
else
  $GAWKEXE ${OPTION} -f ${TESTCASE}.awk                        > ${TESTHOME}/_${TESTCASE} 2>&1 || echo EXIT CODE: $? >> ${TESTHOME}/_${TESTCASE}
fi
# Compare the actual output with the expected (correct) output.
${COMPARE} ${TESTHOME}/${TESTCASE}.ok ${TESTHOME}/_${TESTCASE} && rm -f ${TESTHOME}/_${TESTCASE}

